# Day13笔记

## EF Core

### 数据加载

**预加载**
通过include方法在查询中去加载导航属性，实际上是通过left join完成连表查询，通过theninclude方法进一步加载子实体的相关，也就是再以子实体对应的表和其导航属性对应的表进行left join，以便一次性获取所有所需的数据。

**显示加载**
使用手动配置单个实体的显示加载导航属性，就是拿实体的ID和导航属性对应的表的对应字段进行where筛选。

**延迟加载**
什么时候访问了导航属性，什么时候就会被加载，并且会执行一次数据库。

**N+1问题**
指的是应用程序首先执行一次查询来获取主实体集（这是 "1" 次查询），然后对每个主实体执行一次查询来获取其相关的导航属性数据（这是 "N" 次查询）。这种模式会导致大量的数据库查询，从而显著降低性能。

**拆分查询**
用于预加载的优化，由于预加载会连表查出一些重复的数据，就可以使用AsSplitQuery方法对连表查询进行拆分为两个查询，减少了数据冗余。

**总结**

| 特性                 | Eager Loading          | Lazy Loading                     | Explicit Loading           |
| ---------------------- | ------------------------ | ---------------------------------- | ---------------------------- |
| **控制权**     | 低：数据在查询时加载   | 中：数据在访问导航属性时加载     | 高：数据按需显式加载       |
| **性能**       | 高：单一查询           | 中：可能的 N+1 查询问题          | 高：避免不必要的加载       |
| **代码复杂性** | 低：代码简洁           | 中：需要确保延迟加载不会引起问题 | 高：显式调用加载方法       |
| **适用场景**   | 报告生成、详细数据视图 |筛选、逐步加载数据         | 复杂业务逻辑、特定性能优化 |

### AsQueryable和AsEnumerable区别

- 使用AsEnumerable无论怎样都会查询所有字段，而AsQueryable则是按需所取。
- 使用AsEnumerable会不管是否带有过滤条件，都将所有数据加入到内存中，然后再在内存中进行过滤。而	  AsQueryable会将带有查询条件的SQL执行后的数据加入内存。
- 所以大部分的场景可以用AsQueryable。

### 分页

- 偏移分页：使用skip()跳过（page index-1）*pagesize条数据，使用take()读取pagesize条数据，适用所有分页场景，但是数据量大时，访问后面的数据速度慢
- keyset分页：使用字段大小比较完成，不支持数据断层，效率高

