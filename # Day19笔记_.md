# Day19笔记

### EF Core 不允许在同一个上下文中同时跟踪具有相同主键的多个实体实例。

#### 常见场景

1. **多次查询并附加同一个实体** ：例如，你在同一个上下文中多次查询相同的实体并附加到上下文。
2. **显式附加实体** ：你显式地将实体附加到上下文，而这个实体已经被上下文跟踪。

#### 原因

**数据一致性**

EF Core 的 `DbContext` 实例负责追踪实体的状态，并管理对数据库的所有更改。若在同一个上下文中允许多个具有相同主键的实体实例，这些实体的状态可能会不一致，从而导致数据不一致的问题。

**并发控制**

EF Core 使用乐观并发控制来处理多个操作之间的冲突。如果允许多个具有相同主键的实体实例同时存在于同一个上下文中，EF Core 将无法确定哪一个实体实例应该被优先考虑，从而导致并发控制失效。

**变更跟踪复杂性**

EF Core 的变更跟踪机制依赖于实体的主键来确定每个实体的唯一性。如果允许多个具有相同主键的实体实例同时存在，EF Core 将无法正确跟踪每个实体的状态变化，进而导致无法确定哪些更改需要保存到数据库。

### SaveChanges()过程总结

* **检查上下文是否已释放** ：确保操作在合法上下文中执行。
* **触发 `SavingChanges` 事件** ：允许在保存之前执行自定义逻辑。
* **记录日志** ：在保存开始和完成时记录日志，用于调试和分析。
* **检测更改** ：确保检测到所有实体的更改。
* **执行保存操作** ：实际保存更改到数据库。
* **触发 `SavedChanges` 事件** ：允许在保存之后执行自定义逻辑。
* **处理异常** ：记录并处理并发冲突和其他异常，确保系统的鲁棒性和稳定性。

### 实现拓展点

定义和使用 `SavingChanges` 事件，需要以下步骤：

1. **定义事件处理程序** ：
   首先，你需要定义一个事件处理程序，这是一个方法，它会在事件被触发时执行。在onsavingchanges方法编写自定义逻辑。
2. **订阅事件** ：
   然后，你需要订阅 `SavingChanges` 事件，通过this.SavingChanges += OnSavingChanges订阅。
   
 SavedChanges拓展点也同理。

